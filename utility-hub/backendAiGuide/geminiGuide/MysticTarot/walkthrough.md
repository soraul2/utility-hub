# 미스틱 타로 (Mystic Tarot) 백엔드 구현 워크스루

이 문서는 Gemini 팀(Antigravity)이 구현한 미스틱 타로 백엔드 기능에 대한 기술적 상세 보고서입니다.

## 1. 구현 요약
`tarot_data.json` 기반의 풍부한 카드 데이터와 **8가지의 독창적인 AI 페르소나**를 도입하여 리딩의 몰입감을 극대화했습니다. 또한 사용자 편의를 위한 "오늘의 카드" 기능을 성공적으로 추가했습니다.

## 2. 주요 구현 상세

### 2.1 상세 데이터 통합 및 덱 관리 (`TarotCardService`)
- 이전의 하드코딩된 카드 리스트를 제거하고, `src/main/resources/tarot_data.json`에서 전체 덱을 로드하도록 개선했습니다.
- `ObjectMapper`와 `ResourceLoader`를 사용하여 애플리케이션 시작 시(`@PostConstruct`) 78장의 카드를 자동으로 초기화합니다.
- 각 카드는 이제 단순한 이름뿐만 아니라 `키워드`, `정방향 의미`, `역방향 의미`를 포함한 풍부한 컨텍스트를 가집니다.

### 2.2 다채로운 AI 페르소나 시스템 (`TarotAiService`)
- **다중 페르소나 지원**: 기본 'Mystic' 외에 8명의 개성 넘치는 AI 조수(Assistant)를 구현했습니다.
  - **실비아(현실적)**, **루나(치유)**, **오리온(긍정)**, **녹티스(독설)** 등 각기 다른 어조와 관점을 가진 캐릭터들이 존재합니다.
  - `TarotAssistantType` Enum을 통해 각 캐릭터의 이름, 칭호, 말투, 해석 가이드라인을 중앙에서 관리합니다.
  
- **마스터 포르투나(Fortuna)의 히든 로직**: 
  - '행운의 여신' 포르투나를 선택하면 **"무조건적인 행운"**을 보장하는 특수 로직이 작동합니다.
  - **Positive Card Filtering**: `TarotCardService`에서 부정적인 의미의 카드를 원천 배제하고, `The Sun`, `The Star` 등 긍정적 카드만 뽑히도록 필터링합니다.
  - **Positive Context**: AI 프롬프트에서도 어떤 상황이든 긍정적 징조로 해석하도록 강력한 지시사항이 주입됩니다.

- **동적 프롬프트 엔지니어링**: 
  - 선택된 조수 타입에 따라 `System Prompt`가 동적으로 교체되어, 마치 다른 사람과 대화하는 듯한 UX를 제공합니다.

### 2.3 오늘의 카드 기능 구현 (`TarotReadingService` & `TarotController`)
- **비즈니스 로직**: `DAILY_ONE` 스프레드 타입을 정의하고, 한 장의 카드를 뽑아 하루의 가이드를 제공하는 전용 로직을 구현했습니다.
- **API**: `GET /api/tarot/daily-card` 엔드포인트를 통해 접근 가능하며, 사용자 이름을 선택적으로 입력받아 개인화된 리딩을 제공합니다.
- **데이터 보존**: 모든 오늘의 카드 리딩 기록은 세션 아이디와 함께 MySQL DB에 저장되어 추후 히스토리 조회가 가능합니다.

### 2.4 Swagger API 문서화
- 모든 컨트롤러와 DTO에 `@Operation` 및 `@Schema`를 적용하여 Swagger UI(OneAPI) 상에서 완전한 한글 명세를 제공합니다.

### 2.5 사용자 참여 및 소셜 기능 (v0.6 Update)
- **히스토리 관리**: 로그인한 사용자는 `/api/tarot/history`를 통해 자신의 과거 타로 리딩 기록을 언제든 다시 열람할 수 있습니다.
- **공유 (Sharing)**: `shareUuid`를 기반으로 한 별도의 공유 엔드포인트를 통해, 비회원에게도 안전하게 자신의 타로 결과를 공유할 수 있습니다.
- **게스트 마이그레이션**: 비로그인 상태에서 체험한 결과들을 로컬 스토리지에 임시 보관하다가, 회원가입/로그인 시 `/api/tarot/migrate`를 통해 계정으로 안전하게 이관합니다.
- **사용량 제한 (Rate Limiting)**: 일일 100회 제한을 두어 어뷰징을 방지하고 서비스 안정성을 확보했습니다. (관리자 계정은 예외)

## 3. 기술적 특이사항 및 해결 방법
- **Enum 불일치**: `TarotSpread` 엔티티와 서비스 로직 간의 타입 명칭 불일치(`DAILY_CARD` vs `DAILY_ONE`) 문제를 발견하여 `DAILY_ONE`으로 통일하고 관련 로직을 수정했습니다.
- **데이터 직렬화**: 복잡한 카드 객체를 DB에 효율적으로 저장하기 위해 `DrawnCardDto` 리스트를 JSON 문자열로 변환하여 저장하는 방식을 적용했습니다.

## 4. 성능 및 안정성 최적화 (v0.2.1 Refactored)

실제 운영 환경에서의 고부하 상황을 대비하여 다음과 같은 치명적 병목 지점을 개선했습니다.

### 4.1 DB 커넥션 풀 고갈 방지
- **기존 문제**: AI 응답 대기 시간(2~10초) 동안 DB 트랜잭션을 유지하여 커넥션 풀이 조기에 고갈될 위험이 있었습니다.
- **해결**: `TarotReadingService`에서 AI 호출 로직을 `@Transactional` 외부로 분리하고, 결과 저장 시에만 최소한의 트랜잭션을 사용하도록 구조를 변경했습니다.

### 4.2 ChatClient 리소스 재사용
- **기존 문제**: 요청마다 `ChatClient` 인스턴스를 새로 생성하여 불필요한 GC 부하와 오버헤드가 발생했습니다.
- **해결**: `TarotAiService` 생성 시 `ChatClient`를 한 번만 빌드하여 싱글톤 빈처럼 재사용하도록 최적화했습니다.

## 5. 검증 결과
- **빌드 및 패키징**: `./gradlew build` 시 모든 기능 정상 작동 확인.
- **안정성**: 동시 요청 시 DB 커넥션 점유 시간이 밀리초(ms) 단위로 단축되어 안정적인 운영이 가능해졌습니다.
- **성능**: 객체 생성 오버헤드 감소로 미세한 응답 속도 향상을 확인했습니다.
